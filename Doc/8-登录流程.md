![image](https://github.com/kof123w/MyGame/assets/40864999/aaee0c94-4c3a-4cf8-ae91-0b4ad93eff15)在AppStartInitFinish_CreateLoginUI.初始化后，执行Login界面的初始化

登录面板逻辑：UILoginComponentSystem,针对组件UILoginComponent创建的System

登录面板逻辑：UILoginComponent

逻辑层: LoginHelper中的clientSenderComponent.LoginAsync()是整个连接的过程。

网络层：ClientSenderComponentSystem使用Call(xxx)发送网络消息  Main2NetClient_Login()

![image](https://github.com/kof123w/MyGame/assets/40864999/71f5623e-cb8f-471a-b82f-04504eb57004)

找到消息的处理类，一般为
(
网络消息名字
)_Handler
，如
Main2NetClient_LoginHandler
，需要继承
MessageHandler
（网络消息处理基类），并且带有请求的网络消息与回复的网络消息，并且带有
[MessageHandler(SceneTy
Type.NetClient)]
，在
Run()
函数中，做了如下事情：
1-
移除并添加与初始化
RouterAddressComponent
（路由地址组件）
,
在
ConstVa
Value
中设置的连接
ip
与
端口，并通过路由地址组件获取
realm
地址，
2-
添加
NetComponent
（网络组件），并创建
session
，通过
session.Call()
发送网络消息，它的返回值
就是回复的网络消息（异步）
3-
创建
gateSession
，连接网关服务器，后续与游戏服务器通讯的时候，都是使用这个
GateSession
，
使用
gateSession
的
Call
（），来向网关服务器请求登录。
这里只配置了一台
Realm
服务器，在正式部署时，为了分散性能压力，会配置多台
,
获取
Reaml
地址
时，就会有多个地址。
服务端如何处理
gateSession
的
Call()
呢？还是通过找网络消息名字
_handler
，有
C2R_Login
则找
C2R_LoginHandler
,
在
Run(xxx)
中，做了如下的事情
1-
随机分配一个
Gate

2-
向
gate
请求一个
key
,
客户端可以拿着这个
key
连接
gate
3-
将拿到的
key
写在回复的消息
R2C_Login
中
4-
释放
session
C2R_LoginHandler : MessageSessionHandler<C2R_Login, R2C_Login>,
游戏客户端
session
与服务端
的
session
是两个
session
。
MessageSessionHandler
与
MessageHandler
如何区分使用？
跟消息是不是使用了
ISessionRequest
接口有关，如果使用了，则要使用
MessageSessionHandler
。
FiberInit_Realm
文件中，有一个分发逻辑（类似虚函数），
Invoke
（）类似与时间发布，但是不同的
是，
1- Invoke
类似函数，必须有被调用方，否则异常，调用者跟被调用者属于同一模块，比如
MoveComponent
中的
T
imer
计时器，调用跟被调用的代码均属于移动模块
2-
既然
Invoke
跟函数一样，那么为什么不使用函数呢
?
因为有时候不方便直接调用，比如
Config
加载，
在客户端跟服务端加载方式不一样。比如
T
imerComponent
需要根据
Id
分发
3-
注意，不要把
Invoke
当函数使用，这样会造成代码可读性降低，能用函数不要用
Invoke
4- publish
是事件，抛出去可以没人订阅，调用者跟被调用者属于两个模块，比如任务系统需要知道道
具使用的信息，则订阅道具使用事件
在
C2R_LoginHandler
来判定账号与密码的合法性，然后获取数据库组件：
DBComponent dbComponent = session.Root().GetComponent<DBManagerComponent>
().GetZoneDB(session.Zone);
在
FiberInit_Realm
中添加数据库管理组件
root.AddComponent<DBManagerComponent>();
然后调用语句开始查询，访问其他属性的变量需要使
用
[FriendOf(xxx )](Alt+Enter
就可以了
)
在
Config/StartZoneConfig
中，配置的是有关区（
zone
）的信息，在
session.Zone()
取到的值也是这里
填的区
ID
，配置中也有关于数据库的配置，一个区一个数据库，

![image](https://github.com/kof123w/MyGame/assets/40864999/4a200e70-faf5-4ae0-ad8d-18151bf4b06a)

使用协程锁避免同个账号的写入问题。

![image](https://github.com/kof123w/MyGame/assets/40864999/be1ec6c0-d709-46a3-aeef-9b7fdad1b978)

// 挂上这个组件，5秒就会删除session，所以客户端验证完成要删除这个组件。该组件的作用就是防止外挂一直连接不发消息也不进行权限验证session.AddComponent<SessionAcceptTimeoutComponent>();PlayerComponent 用于管理player实体，MailBoxComponent 增加后就拥有处理网络消息的能力，根据增加时候设定的参数，就能处理参数类型的网络消息，并不是所有的消息都能处理。SessionPlayerComponent 与PlaySessionComponent 区别与关系，相互记录，完成一一映射的关系，可以通过Player找到session，也可以通过session找到Player:session.GetComponent<SessionPlayerComponent>().Player.session有过期的情况，所以经常会出现覆盖的情况。EnterMapHelper里面有进入到另一个地图的步骤  1- 发送进入地图请求  2- 等待场景切换完成  3-发布进入地图的事件处理进入地图的方法：C2G_EnterMapHandler，模拟地图传送的逻辑，先创建一个虚拟地图，登录后传送过去。

![image](https://github.com/kof123w/MyGame/assets/40864999/0d386ff8-0398-4f18-babe-7be3d27e448f)

步骤：
1-
在
player
上加一个
GateMapComponent
，创建临时
MapScene
并赋值给
GateMapComponent
上的
Scene
上。
2-
从
DB
中加载数据，创建
Unit
映射对象实体到刚才创建的
GateScene
中
3-
传送到登录
的场景中去。
T
ransferHelper
.T
ransferAtFrameFinish()
。也就是说在
player
身上加了一个
GateMapComponent
组件，在该组件上创建了一个
gateMap
场景，然后在这个场景上添加
Unit
映射对
象，然后传送过去。
传送会等待一帧在执行，在当前这帧，会回到
EnterMapHelper
中，等待场景切换完成（就是等待传送
的这一帧执行完毕
-
使用
objectW
ait
类），
传送前需要锁定，
Unit
实体如果在传送的状态，无法就行其他的操纵。
传送函数的步骤
(T
ransfer(xxx))
：
1-
获取需要传送单元当前的场景
2-
创建一个传送的消息并赋上对应的
参数
(
位置
id-ActoriId
，对象序列化数据，以及它身上所有的实现了
IT
randfer
接口的组件的序列化数
据
).3-
原单元对象释放，
4-
锁住改单元并且发送请求，锁住是为了避免在传送过程中再对对象进行操
作。
ActorId
是位置
id
，由进程
id
，场景
id
，实体
id
生成一个对应的
id,
M2M_UnitT
ransferRequestHandler
类是处理接收对象的类
(M2M
是
mapTo
ToMap
的意思
)
，步骤如下：
1-
重新创建
Unit
对象。从
request
中的数据反序列化一个对象，同时反序列化这个单元实现了
IT
ransfer
接
口的组件，给这个
unit
添加移动与寻路组件，并设置它的初始位置，同时添加
MailBoxComponent
组件
用来通讯，
2-
在场景中获取一个单位组件（
UnitComponent
）并将反序列化的单元加载该组件上。
3-
发
送一个场景已经改变的网络消息
M2C_StartSceneChange
（
M2C
是
MapTo
ToClient
的意思）
4-
加入
AOI
组
件，用来处理多人同屏的相关逻辑。
5-
通知
Locaition
定位服务器，解锁发送时的锁。
如果
Unit
没有附加在组件上进行管理，那么就会造成内存泄漏永远不能回收，
M2C_StartSceneChangeHandler
处理场景切换消息。

M2C_CreateMyUnitHandler
刚才发送消息的处理类。
