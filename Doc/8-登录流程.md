在AppStartInitFinish_CreateLoginUI.初始化后，执行Login界面的初始化

登录面板逻辑：UILoginComponentSystem,针对组件UILoginComponent创建的System

登录面板逻辑：UILoginComponent

逻辑层: LoginHelper中的clientSenderComponent.LoginAsync()是整个连接的过程。

网络层：ClientSenderComponentSystem使用Call(xxx)发送网络消息  Main2NetClient_Login()

![image](https://github.com/kof123w/MyGame/assets/40864999/71f5623e-cb8f-471a-b82f-04504eb57004)

找到消息的处理类，一般为
(
网络消息名字
)_Handler
，如
Main2NetClient_LoginHandler
，需要继承
MessageHandler
（网络消息处理基类），并且带有请求的网络消息与回复的网络消息，并且带有
[MessageHandler(SceneTy
Type.NetClient)]
，在
Run()
函数中，做了如下事情：
1-
移除并添加与初始化
RouterAddressComponent
（路由地址组件）
,
在
ConstVa
Value
中设置的连接
ip
与
端口，并通过路由地址组件获取
realm
地址，
2-
添加
NetComponent
（网络组件），并创建
session
，通过
session.Call()
发送网络消息，它的返回值
就是回复的网络消息（异步）
3-
创建
gateSession
，连接网关服务器，后续与游戏服务器通讯的时候，都是使用这个
GateSession
，
使用
gateSession
的
Call
（），来向网关服务器请求登录。
这里只配置了一台
Realm
服务器，在正式部署时，为了分散性能压力，会配置多台
,
获取
Reaml
地址
时，就会有多个地址。
服务端如何处理
gateSession
的
Call()
呢？还是通过找网络消息名字
_handler
，有
C2R_Login
则找
C2R_LoginHandler
,
在
Run(xxx)
中，做了如下的事情
1-
随机分配一个
Gate

2-
向
gate
请求一个
key
,
客户端可以拿着这个
key
连接
gate
3-
将拿到的
key
写在回复的消息
R2C_Login
中
4-
释放
session
C2R_LoginHandler : MessageSessionHandler<C2R_Login, R2C_Login>,
游戏客户端
session
与服务端
的
session
是两个
session
。
MessageSessionHandler
与
MessageHandler
如何区分使用？
跟消息是不是使用了
ISessionRequest
接口有关，如果使用了，则要使用
MessageSessionHandler
。
FiberInit_Realm
文件中，有一个分发逻辑（类似虚函数），
Invoke
（）类似与时间发布，但是不同的
是，
1- Invoke
类似函数，必须有被调用方，否则异常，调用者跟被调用者属于同一模块，比如
MoveComponent
中的
T
imer
计时器，调用跟被调用的代码均属于移动模块
2-
既然
Invoke
跟函数一样，那么为什么不使用函数呢
?
因为有时候不方便直接调用，比如
Config
加载，
在客户端跟服务端加载方式不一样。比如
T
imerComponent
需要根据
Id
分发
3-
注意，不要把
Invoke
当函数使用，这样会造成代码可读性降低，能用函数不要用
Invoke
4- publish
是事件，抛出去可以没人订阅，调用者跟被调用者属于两个模块，比如任务系统需要知道道
具使用的信息，则订阅道具使用事件
在
C2R_LoginHandler
来判定账号与密码的合法性，然后获取数据库组件：
DBComponent dbComponent = session.Root().GetComponent<DBManagerComponent>
().GetZoneDB(session.Zone);
在
FiberInit_Realm
中添加数据库管理组件
root.AddComponent<DBManagerComponent>();
然后调用语句开始查询，访问其他属性的变量需要使
用
[FriendOf(xxx )](Alt+Enter
就可以了
)
在
Config/StartZoneConfig
中，配置的是有关区（
zone
）的信息，在
session.Zone()
取到的值也是这里
填的区
ID
，配置中也有关于数据库的配置，一个区一个数据库，

![image](https://github.com/kof123w/MyGame/assets/40864999/4a200e70-faf5-4ae0-ad8d-18151bf4b06a)

使用协程锁避免同个账号的写入问题。

![image](https://github.com/kof123w/MyGame/assets/40864999/be1ec6c0-d709-46a3-aeef-9b7fdad1b978)

// 挂上这个组件，5秒就会删除session，所以客户端验证完成要删除这个组件。该组件的作用就是防止外挂一直连接不发消息也不进行权限验证session.AddComponent<SessionAcceptTimeoutComponent>();PlayerComponent 用于管理player实体，MailBoxComponent 增加后就拥有处理网络消息的能力，根据增加时候设定的参数，就能处理参数类型的网络消息，并不是所有的消息都能处理。SessionPlayerComponent 与PlaySessionComponent 区别与关系，相互记录，完成一一映射的关系，可以通过Player找到session，也可以通过session找到Player:session.GetComponent<SessionPlayerComponent>().Player.session有过期的情况，所以经常会出现覆盖的情况。EnterMapHelper里面有进入到另一个地图的步骤  1- 发送进入地图请求  2- 等待场景切换完成  3-发布进入地图的事件处理进入地图的方法：C2G_EnterMapHandler，模拟地图传送的逻辑，先创建一个虚拟地图，登录后传送过去。


![image](https://github.com/kof123w/MyGame/assets/40864999/0d386ff8-0398-4f18-babe-7be3d27e448f)

