
[ComponentOf(typeof(xxx))]组件描述，表示是哪个实体的组件

[EntitySystemOf(typeof(xxx))] 系统描述

[UIEvent(UIType.UILogin)]:定义ui事件

[Event(SceneType.Demo)] 定义事件，在指定场景的指定事件发生后触发

[ChildOf(typeof(ComputersComponent))] 标明是谁的子实体

[ResponseType(nameof(XXX)] 描述协议返回

[Message(xxx)] 消息协议描述

[MemoryPackable] 协议类型

[MessageHandler(SceneType.xx)] 发消息的处理，注意带有消息种类

[FriendOf(typeof(UILoginComponent))] 表明一个系统与一个组件的关系，加上后才可以修改它的数据。

  - ET8.0使用MemoryPack代替了protobuffer

  - 服务器的结构

![image](https://github.com/kof123w/MyGame/assets/40864999/0e006a0f-a8a5-4bcd-ad13-48737c376b90)

### UI的编写与加载

  1- 在Unity中创建一个UIxxx的prefab
  2- 在UIType中添加对应的变量对应该名字
  3-定义一个事件，在该事件中使用

  await UIHelper.Create(scene, UIType.UILobby, UILayer.Mid);

### 创建UI
  3-定义一个UIxxEevent的类，里面会在OnCreate（）方法中找到该prefab并创建
  4-在UIxxxComponentSystem的Awake（）中会定义其中的逻辑。

### 创建网络消息处理类
![image](https://github.com/kof123w/MyGame/assets/40864999/7e6dc78c-a46e-472b-840b-d0600fddab42)

1表示在哪个场景的消息处理，同时与文件所处的位置有关

![image](https://github.com/kof123w/MyGame/assets/40864999/9333c756-5e11-4bc7-851f-ab881c8ba155)

2 消息处理类对应的处理消息，一条是发送的消息，一条是回复的消息

3 Run（）方法是处理

 
  
